;; -*- mode: common-lisp -*-
;;
;; Copyright (C) 2001 Franz Inc, Berkeley, CA.  All rights reserved.
;; Copyright (C) 2002-2005 Franz Inc, Oakland, CA.  All rights reserved.
;;
;; This code is free software; you can redistribute it and/or
;; modify it under the terms of the version 2.1 of
;; the GNU Lesser General Public License as published by 
;; the Free Software Foundation, as clarified by the Franz
;; preamble to the LGPL found in
;; http://opensource.franz.com/preamble.html.
;;
;; This code is distributed in the hope that it will be useful,
;; but without any warranty; without even the implied warranty of
;; merchantability or fitness for a particular purpose.  See the GNU
;; Lesser General Public License for more details.
;;
;; Version 2.1 of the GNU Lesser General Public License can be
;; found at http://opensource.franz.com/license.html.
;; If it is not present, you can access it from
;; http://www.gnu.org/copyleft/lesser.txt (until superseded by a newer
;; version) or write to the Free Software Foundation, Inc., 59 Temple
;; Place, Suite 330, Boston, MA  02111-1307  USA
;;
;; $Id: nlm.cl,v 1.2 2006/01/23 21:33:49 dancy Exp $

(in-package :user)

;; This file implements the Network Lock Monitor (NLM) protocol. 

;; Ref: http://www.opengroup.org/onlinepubs/009629799/chap9.htm

(defparameter *nlm-gate* (mp:make-gate nil))
(defparameter *nlm-debug* t)
(defparameter *nlm-retry-interval* 2) ;; seconds

;;; Start autogenerated code 

(defun xdr-netobj (xdr &optional vec)
  (ecase (xdr-direction xdr)
    (:build 
     (xdr-opaque-variable xdr :vec vec))
    (:extract
     (xdr-opaque-variable xdr))))

;; enum nlm-stats
(eval-when (compile load eval)
 (defconstant *lck-granted* 0)
 (defconstant *lck-denied* 1)
 (defconstant *lck-denied-nolocks* 2)
 (defconstant *lck-blocked* 3)
 (defconstant *lck-denied-grace-period* 4))

(defun xdr-nlm-stats (xdr &optional int)
 (xdr-int xdr int))

(defxdrstruct nlm-stat ((nlm-stats stat)))

(defxdrstruct nlm-res ((netobj cookie)
                          (nlm-stat stat)))

(defxdrstruct nlm-holder ((bool exclusive)
                          (int uppid)
                          (netobj oh)
                          (unsigned l-offset)
                          (unsigned l-len)))

(defxdrunion nlm-testrply (nlm-stats stat)
 (
  (*lck-denied* nlm-holder holder)
  (:default void)
 ))

(defxdrstruct nlm-testres ((netobj cookie)
                          (nlm-testrply test-stat)))

(defxdrstruct nlm-lock ((string caller-name)
                          (netobj fh)
                          (netobj oh)
                          (int uppid)
                          (unsigned l-offset)
                          (unsigned l-len)))

(defxdrstruct nlm-lockargs ((netobj cookie)
                          (bool block)
                          (bool exclusive)
                          (nlm-lock alock)
                          (bool reclaim)
                          (int state)))

(defxdrstruct nlm-cancargs ((netobj cookie)
                          (bool block)
                          (bool exclusive)
                          (nlm-lock alock)))

(defxdrstruct nlm-testargs ((netobj cookie)
                          (bool exclusive)
                          (nlm-lock alock)))

(defxdrstruct nlm-unlockargs ((netobj cookie)
                          (nlm-lock alock)))

;; enum fsh-mode
(eval-when (compile load eval)
 (defconstant *fsm-dn* 0)
 (defconstant *fsm-dr* 1)
 (defconstant *fsm-dw* 2)
 (defconstant *fsm-drw* 3))

(defun xdr-fsh-mode (xdr &optional int)
 (xdr-int xdr int))

;; enum fsh-access
(eval-when (compile load eval)
 (defconstant *fsa-none* 0)
 (defconstant *fsa-r* 1)
 (defconstant *fsa-w* 2)
 (defconstant *fsa-rw* 3))

(defun xdr-fsh-access (xdr &optional int)
 (xdr-int xdr int))

(defxdrstruct nlm-share ((string caller-name)
                          (netobj fh)
                          (netobj oh)
                          (fsh-mode mode)
                          (fsh-access access)))

(defxdrstruct nlm-shareargs ((netobj cookie)
                          (nlm-share share)
                          (bool reclaim)))

(defxdrstruct nlm-shareres ((netobj cookie)
                          (nlm-stats stat)
                          (int sequence)))

(defxdrstruct nlm-notify ((string name)
                          (long state)))

(eval-when (compile load eval)
 (defconstant *nlm-prog* 100021)
 (defconstant *nlm-versx* 3)
 (defconstant *nlm-null* 0)
 (defconstant *nlm-test* 1)
 (defconstant *nlm-lock* 2)
 (defconstant *nlm-cancel* 3)
 (defconstant *nlm-unlock* 4)
 (defconstant *nlm-granted* 5)
 (defconstant *nlm-test-msg* 6)
 (defconstant *nlm-lock-msg* 7)
 (defconstant *nlm-cancel-msg* 8)
 (defconstant *nlm-unlock-msg* 9)
 (defconstant *nlm-granted-msg* 10)
 (defconstant *nlm-test-res* 11)
 (defconstant *nlm-lock-res* 12)
 (defconstant *nlm-cancel-res* 13)
 (defconstant *nlm-unlock-res* 14)
 (defconstant *nlm-granted-res* 15)
 (defconstant *nlm-share* 20)
 (defconstant *nlm-unshare* 21)
 (defconstant *nlm-nm-lock* 22)
 (defconstant *nlm-free-all* 23)
 (defconstant *nlm4-vers* 4)
 (defconstant *nlmproc4-null* 0)
 (defconstant *nlmproc4-test* 1)
 (defconstant *nlmproc4-lock* 2)
 (defconstant *nlmproc4-cancel* 3)
 (defconstant *nlmproc4-unlock* 4)
 (defconstant *nlmproc4-granted* 5)
 (defconstant *nlmproc4-test-msg* 6)
 (defconstant *nlmproc4-lock-msg* 7)
 (defconstant *nlmproc4-cancel-msg* 8)
 (defconstant *nlmproc4-unlock-msg* 9)
 (defconstant *nlmproc4-granted-msg* 10)
 (defconstant *nlmproc4-test-res* 11)
 (defconstant *nlmproc4-lock-res* 12)
 (defconstant *nlmproc4-cancel-res* 13)
 (defconstant *nlmproc4-unlock-res* 14)
 (defconstant *nlmproc4-granted-res* 15)
 (defconstant *nlmproc4-share* 20)
 (defconstant *nlmproc4-unshare* 21)
 (defconstant *nlmproc4-nm-lock* 22)
 (defconstant *nlmproc4-free-all* 23)
)

(def-rpc-program (nlm #.*nlm-prog*)
  (
   ((1 #.*nlm-versx*)
     (#.*nlm-null* nlm-null void void)
     (#.*nlm-test* nlm-test nlm-testargs nlm-testres)
     (#.*nlm-lock* nlm-lock nlm-lockargs nlm-res)
     (#.*nlm-cancel* nlm-cancel nlm-cancargs nlm-res)
     (#.*nlm-unlock* nlm-unlock nlm-unlockargs nlm-res)
     (#.*nlm-granted* nlm-granted nlm-testargs nlm-res)
     (#.*nlm-test-msg* nlm-test-msg nlm-testargs void)
     (#.*nlm-lock-msg* nlm-lock-msg nlm-lockargs void)
     (#.*nlm-cancel-msg* nlm-cancel-msg nlm-cancargs void)
     (#.*nlm-unlock-msg* nlm-unlock-msg nlm-unlockargs void)
     (#.*nlm-granted-msg* nlm-granted-msg nlm-testargs void)
     (#.*nlm-test-res* nlm-test-res nlm-testres void)
     (#.*nlm-lock-res* nlm-lock-res nlm-res void)
     (#.*nlm-cancel-res* nlm-cancel-res nlm-res void)
     (#.*nlm-unlock-res* nlm-unlock-res nlm-res void)
     (#.*nlm-granted-res* nlm-granted-res nlm-res void)
     (#.*nlm-share* nlm-share nlm-shareargs nlm-shareres)
     (#.*nlm-unshare* nlm-unshare nlm-shareargs nlm-shareres)
     (#.*nlm-nm-lock* nlm-nm-lock nlm-lockargs nlm-res)
     (#.*nlm-free-all* nlm-free-all nlm-notify void)
   )
   (#.*nlm4-vers*
     (#.*nlmproc4-null* nlmproc4-null void void)
     (#.*nlmproc4-test* nlmproc4-test nlm4-testargs nlm4-testres)
     (#.*nlmproc4-lock* nlmproc4-lock nlm4-lockargs nlm4-res)
     (#.*nlmproc4-cancel* nlmproc4-cancel nlm4-cancargs nlm4-res)
     (#.*nlmproc4-unlock* nlmproc4-unlock nlm4-unlockargs nlm4-res)
     (#.*nlmproc4-granted* nlmproc4-granted nlm4-testargs nlm4-res)
     (#.*nlmproc4-test-msg* nlmproc4-test-msg nlm4-testargs void)
     (#.*nlmproc4-lock-msg* nlmproc4-lock-msg nlm4-lockargs void)
     (#.*nlmproc4-cancel-msg* nlmproc4-cancel-msg nlm4-cancargs void)
     (#.*nlmproc4-unlock-msg* nlmproc4-unlock-msg nlm4-unlockargs void)
     (#.*nlmproc4-granted-msg* nlmproc4-granted-msg nlm4-testargs void)
     (#.*nlmproc4-test-res* nlmproc4-test-res nlm4-testres void)
     (#.*nlmproc4-lock-res* nlmproc4-lock-res nlm4-res void)
     (#.*nlmproc4-cancel-res* nlmproc4-cancel-res nlm4-res void)
     (#.*nlmproc4-unlock-res* nlmproc4-unlock-res nlm4-res void)
     (#.*nlmproc4-granted-res* nlmproc4-granted-res nlm4-res void)
     (#.*nlmproc4-share* nlmproc4-share nlm4-shareargs nlm4-shareres)
     (#.*nlmproc4-unshare* nlmproc4-unshare nlm4-shareargs nlm4-shareres)
     (#.*nlmproc4-nm-lock* nlmproc4-nm-lock nlm4-lockargs nlm4-res)
     (#.*nlmproc4-free-all* nlmproc4-free-all nlm4-notify void)
   ))

  (mp:open-gate *nlm-gate*))

;; End auto-generated code.

;; Helpers

(defun nlm-status-to-string (status)
  (ecase status
    (#.*lck-granted* "GRANTED")
    (#.*lck-denied* "DENIED")
    (#.*lck-denied-nolocks* "DENIED_NOLOCKS")
    (#.*lck-blocked* "BLOCKED")
    (#.*lck-denied-grace-period* "DENIED_GRACE_PERIOD")))

(defun nlm-log-status (status)
  (logit "==> ~a~%" (nlm-status-to-string status)))

(defmacro nlm-vers-to-nfs-vers (vers)
  `(ecase ,vers
     ((1 3) 
      2)
     (4 
      3)))

(defun nlm-lock-to-string (lock)
  (let ((fh (nlm-lock-fh lock)))
    (if (fh-p fh)
	(setf fh (fh-pathname fh)))
    
    (format nil "(Caller: ~a, file: ~a, off: ~d, len: ~d)"
	    (nlm-lock-caller-name lock)
	    fh
	    (nlm-lock-l-offset lock)
	    (nlm-lock-l-len lock))))

(defun nlm-privatize-lock (lock vers)
  (setf (nlm-lock-fh lock) 
    (vec-to-fhandle (nlm-lock-fh lock) (nlm-vers-to-nfs-vers vers)))
  (setf (nlm-lock-oh lock) (xdr-extract-vec (nlm-lock-oh lock)))
  lock)

(defvar *nlm-state-lock* (mp:make-process-lock))

(defvar *nlm-locks* nil)

(defvar *nlm-retry-list* nil)

(defun nlm-lock-match-p (alock1 alock2)
  (and (eq (nlm-lock-fh alock1) (nlm-lock-fh alock2))
       (equalp (nlm-lock-oh alock1) (nlm-lock-oh alock2))
       (= (nlm-lock-uppid alock1) (nlm-lock-uppid alock2))
       (= (nlm-lock-l-offset alock1) (nlm-lock-l-offset alock2))
       (= (nlm-lock-l-len alock1) (nlm-lock-l-len alock2))))

(defun nlm-find-lock (alock list)
  (dolist (entry list)
    (if (nlm-lock-match-p alock entry)
	(return entry))))

(defun nlm-find-retry-lock (alock)
  (dolist (entry *nlm-retry-list*)
    (if (nlm-lock-match-p alock (car entry))
	(return entry))))
  

;; XXX 
;; Windows has no concept of locking from "here to the current/future
;; of end of file" like Unix does.  This what is meant with length is
;; 0.  We simulate it here by using a very large length.  On 32-bit
;; platforms, the third arg to _locking is 32-bits so there may be
;; problems with locking large files.  We may need to provide an
;; interface to LockFile() which supports 64-bit args (in two
;; 32-bit pieces).

;; returns t if lock was successful, nil otherwise
(defun nlm-do-lock (f offset length)
  (file-position f offset)
  (if (= length 0)
      (setf length #x7fffffff))
  (handler-case (excl.osi:locking f #.*lk-nblck* length)
    (syscall-error (c)
      (if* (= (syscall-error-errno c) #.excl.osi:*eacces*)
	 then nil
	 else (error c)))
    (:no-error (&rest args)
      (declare (ignore args))
      t)))

(defun nlm-do-unlock (f offset length)
  (file-position f offset)
  (if (= length 0)
      (setf length #x7fffffff))
  (excl.osi:locking f #.*lk-unlck* length))

(defun nlm-try-lock (alock exclusive)
  (let ((status #.*lck-denied*))
    (with-nfs-open-file (f (nlm-lock-fh alock)
			   (if exclusive :output :input)
			   :of of)
      (handler-case (nlm-do-lock f (nlm-lock-l-offset alock)
				  (nlm-lock-l-len alock))
	(error (c)
	  (logit "NSM: Unexpected error during LOCK call: ~a~%" c))
	(:no-error (success)
	  (if* success
	     then (incf (openfile-refcount of))
		  (setf status #.*lck-granted*)
		  (mp:with-process-lock (*nlm-state-lock*)
		    (push alock *nlm-locks*))
		  ;; XXXX need to establish monitoring 
		  ))))
    
    status))

;; Procedures

(defun nlm-null (arg vers peer)
  (declare (ignore arg))
  (if *nlm-debug* 
      (logit "NLM: ~a: NULL~a~%" 
	     (socket:ipaddr-to-dotted (rpc-peer-addr peer))
	     vers)))

(defun nlm-lock (arg vers peer)
  (let* ((alock (nlm-privatize-lock (nlm-lockargs-alock arg) vers))
	 (block (nlm-lockargs-block arg))
	 (exclusive (nlm-lockargs-exclusive arg))
	 (fh (nlm-lock-fh alock))
	 (status #.*lck-denied*))
    (if *nlm-debug*
	(logit "~
NLM: ~a: LOCK (L: ~a, block: ~a, excl: ~a, reclaim: ~a, state: ~a)~%"
	       (socket:ipaddr-to-dotted (rpc-peer-addr peer))
	       (nlm-lock-to-string alock)
	       (nlm-lockargs-block arg)
	       (nlm-lockargs-exclusive arg)
	       (nlm-lockargs-reclaim arg)
	       (nlm-lockargs-state arg)))
    
    ;; XXX: check for valid access (host and user).
    
    ;; XXX  all locks in windows are exclusive.
    
    ;; XXX -- need proper synchronization to prevent concurrent
    ;; access to fhandles hash tables, and other relevant shared
    ;; structured.  openfile stuff has been modified but I still
    ;; need to check for stuff that calls close-open-file.
    
    (when (fh-p fh)
      (setf status (nlm-try-lock alock exclusive))
      
      (if* (and (= status #.*lck-denied*) block)
	 then (setf status #.*lck-blocked*)
	      (mp:with-process-lock (*nlm-state-lock*)
		(if (not (nlm-find-retry-lock alock))
		    (push (cons alock exclusive)
			  *nlm-retry-list*)))))
	
    (if *nlm-debug*
	(nlm-log-status status))

    (make-nlm-res
     :cookie (nlm-lockargs-cookie arg)
     :stat (make-nlm-stat :stat status))))

(defun nlm-unlock (arg vers peer)
  (let* ((alock (nlm-privatize-lock (nlm-unlockargs-alock arg) vers))
	 (fh (nlm-lock-fh alock))
	 (status #.*lck-denied*))
    (if *nlm-debug*
	(logit "~
NLM: ~a: UNLOCK ~a~%"
	       (socket:ipaddr-to-dotted (rpc-peer-addr peer))
	       (nlm-lock-to-string alock)))
    
    ;; XXX: check for valid access (host and user).
    
    (if (fh-p fh)
	(mp:with-process-lock (*nlm-state-lock*)
	  (let ((entry (nlm-find-lock alock *nlm-locks*)))
	    (if* entry
	       then ;; The file should already be in the open file cache
		    ;; since it must remain open to retain the locks.
		    (with-nfs-open-file (f fh :any :of of)
		      (handler-case (nlm-do-unlock f (nlm-lock-l-offset alock)
						   (nlm-lock-l-len alock))
			(error (c)
			  (logit "~
NSM: Unexpected error during UNLOCK call: ~a~%" 
				 c))
			(:no-error (&rest args)
			  (declare (ignore args))
			  (decf (openfile-refcount of))
			  (setf status #.*lck-granted*)
			  (setf *nlm-locks* (delete entry *nlm-locks*))
			  ;; XXX turn off monitoring if necessary
			  )))))))

    (if *nlm-debug*
	(nlm-log-status status))
    
    (make-nlm-res
     :cookie (nlm-unlockargs-cookie arg)
     :stat (make-nlm-stat :stat status))))

(defun nlm-cancel (arg vers peer)
  (let ((alock (nlm-privatize-lock (nlm-cancargs-alock arg) vers))
	(status #.*lck-denied*))
    
    (if *nlm-debug*
	(logit "~
NLM: ~a: CANCEL (L: ~a, block: ~a, excl: ~a)~%"
	       (socket:ipaddr-to-dotted (rpc-peer-addr peer))
	       (nlm-lock-to-string alock)
	       (nlm-cancargs-block arg)
	       (nlm-cancargs-exclusive arg)))
    
    ;; The spec says that block, exclusive, and alock should
    ;; all match exactly with those specified in the original
    ;; NLM_LOCK call.  However, during testing it looks like
    ;; linux uses a different block arg.  Perhaps it does
    ;; that on purpose?
    ;; the spec says that LCK_GRANTED may be returned
    ;; even if the alock.oh doesn't match.
    ;; LCK_GRANTED may also be returned if there is no match.
    ;; very strange.  The spec is very bad.  It seems to contradict
    ;; itself.  Need to find out what Solaris does.  In the meantime,
    ;; we'll be liberal.
    ;; Linux compares file handle, pid, start, and end.
    ;; Solaris does ???

    (mp:with-process-lock (*nlm-state-lock*)
      (let ((entry (nlm-find-retry-lock alock)))
	(if* entry
	   then (setf status #.*lck-granted*)
		(setf *nlm-retry-list* (delete entry *nlm-retry-list*)))))
    
    (if *nlm-debug*
	(nlm-log-status status))
    
    (make-nlm-res
     :cookie (nlm-cancargs-cookie arg)
     :stat (make-nlm-stat :stat status))))

(defun nlm-lock-retry-loop ()
  (loop
    (mp:with-process-lock (*nlm-state-lock*)
      (let (removals)
	(dolist (entry *nlm-retry-list*)
	  (let* ((alock (car entry))
		 (exclusive (cdr entry))
		 (status (nlm-try-lock alock exclusive)))
	    
	    (when (= status #.*lck-granted*)
	      (if *nlm-debug*
		  (logit "Deferred lock ~a granted.~%" 
			 (nlm-lock-to-string alock)))
	      
	      
	      
	      (push entry removals))))
	
	(if removals
	    (dolist (entry removals)
	      (setf *nlm-retry-list* (delete entry *nlm-retry-list*))))))
      
    (sleep *nlm-retry-interval*)))
